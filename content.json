{"meta":{"title":"白衣秀才","subtitle":"青春就是疯狂的奔跑，然后华丽的跌倒，站起来，再跑……","description":"青春就是疯狂的奔跑，然后华丽的跌倒，站起来，再跑……","author":"白衣秀才","url":"http://penglei.top"},"pages":[{"title":"","date":"2017-01-02T06:46:12.611Z","updated":"2017-01-02T06:46:12.611Z","comments":true,"path":"404.html","permalink":"http://penglei.top/404.html","excerpt":"","text":"����404ҳ�� // �������ŵĲ���"},{"title":"分类","date":"2017-01-02T06:50:24.000Z","updated":"2017-01-03T12:20:53.779Z","comments":false,"path":"categories/index.html","permalink":"http://penglei.top/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-01-02T06:50:56.000Z","updated":"2017-01-03T12:20:39.618Z","comments":false,"path":"about/index.html","permalink":"http://penglei.top/about/index.html","excerpt":"","text":""},{"title":"我们只是世界的一偶，如果你想了解我，请点我！","date":"2017-01-02T06:48:17.000Z","updated":"2017-01-02T12:43:28.168Z","comments":false,"path":"tags/index.html","permalink":"http://penglei.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"懒加载session 无法打开 no session or session was closed 解决办法（完美解决）","slug":"java-session","date":"2017-01-03T15:10:29.000Z","updated":"2017-01-03T15:40:06.154Z","comments":true,"path":"2017/01/03/java-session/","link":"","permalink":"http://penglei.top/2017/01/03/java-session/","excerpt":"","text":"摘要&ensp;&ensp;&ensp;&ensp;首先说明一下，hibernate的延迟加载特性(lazy)。所谓的延迟加载就是当真正需要查询数据时才执行数据加载操作。因为hibernate当中支持实体对象，外键会与实体对象关联起来。如果没有这一特性，当查询某一个含有外键的实体对象时，hibernate会把其他实体对象的数据都查询出来。简单的来说，当你想查询某个对象时，实际上调用了多条查询语句。有了延迟加载特性，就避免了这种情况的发生，当你真正的使用get另外一个实体对象时，才再执行下面一条查询语句。&ensp;&ensp;&ensp;&ensp;但有些时候，这个特性却会给我们应用中带来一些问题。这个问题相信大家并不陌生了，hibernate的延迟加载(lazy)特性的确不错的优点，如果没了这个特性，我相信大家在处理一些外键的对象时会头大起来，因为效率十分的低。甚至很多人都觉得使用jdbc要比hibernate要高效甚至方便得多，而迫使不去使用hibernate。&ensp;&ensp;&ensp;&ensp;我想说，没错，使用jdbc在效率上的确可能要快许多，但差距也不会太大的，因为hibernate本身就支持多种查询方式，SQL、HQL、 DetachedCriteria等。而相反的，hibernate在维护性上比jdbc强很多，因为是实体对象的关系。我相信如果您使用过jdbc来实现注册功能的话，会深有体会。 问题原因&ensp;&ensp;&ensp;&ensp;提示session已关闭(no session or session was closed) 触发这个问题的原因在于，hibernate在查询操作完毕的时候会自动的把session关闭掉，为了降低使用的资源。但问题也这样产生了，不要忘了之前所说的hibernate特性，此时再调用get实体方法的时候就会有可能出现这个错误。因为session已经关闭而不能继续执行查询了。 解决办法1. 关闭延迟加载特性。&ensp;&ensp;&ensp;&ensp;操作起来比较简单，因为hibernate的延迟加载特性是在hbm配置里面可控制的。默认lazy=”true”，在many-to-one中添加属性lazy=”false”，就不详细叙述了。 &lt;many-to-one name=&quot;category&quot; lazy=&quot;false&quot; class=&quot;com.penglei.onlineshop.category.vo.Category&quot; column=&quot;cid&quot;&gt;&lt;/many-to-one&gt; 但使用这个解决办法带来的隐患是十分大的。首先，出现no session or session was closed就证明了您已经在使用外键关联表，如果去掉延迟加载的话，则表示每次查询的开销都会变得十分的大，如果关联表越多，后果也可以想象得到。所以不建议使用这个方法解决。 2. 在session关闭之前把我们想要查询的数据先获取了。&ensp;&ensp;&ensp;&ensp;然而有时会出现一种情况就是使用第一种方法并不能解决问题。这时我们需要了解一下session什么时候关闭，也就是它的生命周期。通常情况下hibernate会在查询数据关闭session，而使用getHibernateTemplate().get方法查询后会延迟关闭的时间。会在事务结束后才关闭。&ensp;&ensp;&ensp;&ensp;使用拦截器(Interceptor)或过滤器(Filter)控制session。&ensp;&ensp;&ensp;&ensp;spring为解决hibernate这一特性提供的解决方案，可以有效的控制session生命周期。 在web.xml添加一个拦截器： &lt;!-- 用于解决懒加载的问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate3.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &ensp;&ensp;&ensp;&ensp;决懒加载的问题，但是对于很多新手来说，有很多疑问，为什么把这段代码粘贴进去了好像还是没有什么用。 &ensp;&ensp;&ensp;&ensp;所以需要注意的是这段代码一定要放在web.xml文件的最开始，如此方可解决问题。","categories":[{"name":"Java","slug":"Java","permalink":"http://penglei.top/categories/Java/"}],"tags":[{"name":"no session or session was closed","slug":"no-session-or-session-was-closed","permalink":"http://penglei.top/tags/no-session-or-session-was-closed/"},{"name":"懒加载","slug":"懒加载","permalink":"http://penglei.top/tags/懒加载/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://penglei.top/tags/Hibernate/"},{"name":"spring","slug":"spring","permalink":"http://penglei.top/tags/spring/"}]},{"title":"XStream将java对象转换为xml时，对象字段中的下划线\"_\"，转换后变成了两个的解决办法","slug":"XStream_java","date":"2017-01-02T03:50:30.000Z","updated":"2017-01-03T13:53:22.818Z","comments":true,"path":"2017/01/02/XStream_java/","link":"","permalink":"http://penglei.top/2017/01/02/XStream_java/","excerpt":"","text":"问题产生原因及解决办法在前几天的一个项目中，由于数据库字段的命名原因 其中有两项：一项叫做”市场价格”一项叫做”商店价格” 为了便于区分，遂分别将其命名为market_price和shop_price.对应的实体类命名于此相似。可是在后台使用xstream将数据读出转换为对xml对象时，前台使用extjs的ajax请求，所有其他的属性在前台都可以被解析，唯独 此二者不可解析，仔细检查了一遍也没有发现是什么原因。后来将生产的xml文件粘贴到notepad 放大后才发现原有得market_price，已经变成了market__price 知道了为什么解析不了的原因。于是在网上搜索找到了一个可行的办法：通过转换过滤来解决这个问题。具体解决方法如下： String xml = &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;utf-8\\&quot;?&gt;\\n&quot; + sm.toXML(results); xml=xml.replace(&quot;__&quot;, &quot;_&quot;);","categories":[{"name":"Java","slug":"Java","permalink":"http://penglei.top/categories/Java/"}],"tags":[{"name":"XStream","slug":"XStream","permalink":"http://penglei.top/tags/XStream/"},{"name":"下划线","slug":"下划线","permalink":"http://penglei.top/tags/下划线/"},{"name":"bug","slug":"bug","permalink":"http://penglei.top/tags/bug/"},{"name":"xml","slug":"xml","permalink":"http://penglei.top/tags/xml/"}]}]}